## 함수형 프로그래밍
객체 지향 패러다임과 마찬가지로 하나의 프로그래밍 패러다임

### 객체 지향 프로그래밍
- 움직이는 부분을 캡슐화하여 코드의 이해를 도움

### 함수형 프로그래밍
- **부수효과 없는 순수 함수들을 블록처럼 조립해서 프로그램을 만드는 패러다임**
- 움직이는 부분을 최소화하여 코드의 이해를 도움

#### - 이 두 개념은 상충하는 개념이 아니라, 함께 조화되어 사용할 수 있음
#### - 함수를 합성하여 복잡한 프로그램을 쉽게 만듬
#### - 부수 효과를 공통적인 방법으로 추상화하는 것
- 값을 반환하는 것 이외에 부수적으로 발생하는 일들을 의미
- 변수를 수정하거나, I/O 작업 등이 해당
- 사람이 한 번에 인지할 수 있는 작업은 한정되어 있음
- 부수 효과가 많은 코드는 이해하고 결과를 예측하기 어려울 수 있음

---

### 함수의 합성?
- 특정 함수의 공역이 다른 함수의 정의역과 일치하는 경우, 두 함수를 이어서 새로운 함수를 만드는 연산을 함수 합성이라고 함
- 프로그래밍에서 공역과 정의역은 타입에 해당
  - A 함수에서 int 타입 반환, B 함수에서 int 타입을 인자로 받음
  - B(A())와 같은 형태로 호출하는 것
- 함수형 프로그래밍은 함수를 합성하여 복잡한 프로그램을 쉽게 만듬
- 입력이 들어오면 부수 효과의 발생과 함께 결과를 반환할 수 있음
- 하지만, **부수 효과가 존재하는 함수는 합성하기가 까다로움**

```java
    // 부수 효과가 존재하는 sum 함수는 다른 함수와 합성하기 까다로울 수 있음
    // 1. 다른 함수에서 1부터 1000까지 더하는 함수가 필요하다면?
    // 2. 다른 함수에서 1부터 100까지 곱하는 함수가 필요하다면?
    int sum(){
        int sum = 0;
        for(int i=1; i<=100; i++){
            sum += i;
        }
        return sum;
    }
    // 합을 구하려면 sum() 내부 수정
    // 곱을 구하려면 또 다른 함수 수정
    // 범위를 바꾸려면 또 내부 수정
    // 함수가 하나의 작업만 가능 -> 닫힌 구조
```

- **순수 함수(Pure Function)**은 같은 입력이 들어오면, 항상 같은 값을 반환하는 함수를 의미
- 순수 함수는 부수 효과를 일으키지 않음
- 함수형 프로그래밍에서 함수 합성은 순수 함수로 이루어짐
```java
// sum() 내부를 수정하지 않아도 됨
// loop, range, 연산 로직이 이미 분리되어 있으니까
// 단지 "입력 값만 바꾸면 다른 동작을 만들어낼 수 있음"
class FunctionCompositionTest{
	@Test
	@DisplayName("함수 합성")
	void fp(){
		System.out.println(sum());
		System.out.println(factorial(10));
	}
	
	// 1부터 100까지의 합
	private int sum(){
		return loop((a, b) -> a + b, 0, range(1, 100));
	}
	
	// 팩토리얼
	private int factorial(){
		return loop((a, b) -> a * b, 1, range(1, n));
	}
	
    private int loop(BiFunction<Integer, Integer, Integer> fn, int sum, Queue<Integer> queue) {
      if (queue.isEmpty()) {
          return sum;
      }
      return loop(fn, fn.apply(sum, queue.poll()), queue);
    }

    private Queue<Integer> range(Integer start, Integer to) {
      return IntStream.rangeClosed(start, to)
              .boxed()
              .collect(Collectors.toCollection(LinkedList::new));
    }
}
```
---
## 현업 패턴 예시
### Optional
- 유저 검색 -> 권한 체크 -> DTO 변환
```java
    // 1. Optional
    // 유저 검색 -> 권한 체크 -> DTO 변환
    public Optional<UserDto> findUser(Long id){
        return userRepository.findById(id) // Optional<User>
                        .filter(User::isActive)    // User -> boolean
                        .map(this::toDto);         // User -> UserDto
    }
    public UserDto toDto(User user){
        return new UserDto(user.getId(), user.getName());
    }
```
- 특징
  - null 체크 없음
  - if 없음
  - 함수(User::isActive, this::toDto)를 합성해서 흐름을 만듬
  - 순수 함수 기반이므로 테스트 쉽고 재사용 쉬움

### Stream.map / filter / reduce
- 주문 리스트에서의 총 금액
```java
    int sum = orders.stream()
            .filter(Order::isPaid)
            .map(Order::getPrice)
            .reduce(0, Integer::sum);
```
- 상태(sum 변수)를 직접 변경하지 않음
- 순수 함수들의 합성(filter -> map -> reduce)
- 코드의 역할이 "데이터 흐름"처럼 자연스럽게 읽힘
